1. Evaluation of Your Duration Intelligence Design
1.1 Duration Prediction Models

Track historical task execution data‚Ä¶ build feature-based predictions‚Ä¶ generate confidence scores and emit prediction signals.

Strengths

You‚Äôre explicitly modelling:

type

complexity

assignee

actual duration

variance

Using similar past tasks and confidence scores is exactly what you want for:

plan vs. actual analysis

SLA risk

capacity planning

Suggested refinements

Feature set
Add features that will massively help:

Client/account ID (some clients introduce consistent drag)

Channel/domain (SEO, PPC, Email, Dev, Design)

‚ÄúAI-involved‚Äù flag (AI-assisted vs purely human)

Context size (e.g. number of assets/pages)

Urgency / SLA tier

Model layering

Start with heuristic baselines per (task_type, complexity, role).

Then refine with:

per-assignee offsets (some people are consistently faster/slower)

client-specific adjustments

This keeps things interpretable and avoids premature overfitting.

Confidence score design

Derive from:

Number of similar past samples

Variance in those samples

Recency (last 90 days weighted more)

Use confidence to:

drive UI: ‚ÄúEstimated 3h (low confidence)‚Äù

decide when to ask humans for manual adjustments

Cold start strategy

For new clients/task types, fall back to:

global defaults per task type

then adapt quickly as data comes in

Make that visible: ‚ÄúUsing global baseline (no client history yet).‚Äù

1.2 Resource Optimization

Define staff capacity‚Ä¶ balance workload‚Ä¶ consider skills, load, predicted durations.

Strengths

Exactly what‚Äôs needed to move from ‚Äútask assignment‚Äù ‚Üí true scheduling engine.

You‚Äôre correctly tying capacity, skills, and durations together.

Suggested refinements

Capacity model granularity

Represent capacity in time buckets:

e.g. daily granularity with available_hours[day] per user.

Include:

focus constraints (e.g. max context switches per day)

soft vs hard constraints (preferences vs rules)

Assignment objective function
Think like a solver even if you implement greedily at first:

Minimise: overload (hours beyond capacity)

Minimise: SLA breach risk

Minimise: context switching

Maximise: skill fit + seniority fit

Maximise: commercial impact completed per unit time

Algorithm roadmap

v1: greedy:

sort tasks by priority

assign to best-fit available staff using predicted duration

v2: add ‚Äúlook ahead‚Äù to avoid overloading the same person

v3: if needed, move to a CP-SAT / linear optimisation style approach

Human override loop

Every assignment plan should be:

previewable

editable

re-runnable

Changes by humans should feed back as learning signals about realistic capacity/constraints.

1.3 Commercial Impact Prioritization

Score tasks/projects by revenue impact, client tier, deadline, strategic weight‚Ä¶ feed into Priority Engine.

Strengths

This is the missing ‚Äúwhy‚Äù behind prioritisation: commercial and strategic impact.

Integrating with the Priority Engine means you‚Äôre not building another parallel scoring system.

Suggested refinements

Explicit scoring formula

Example:

impact_score =
  f(revenue_impact) * w1 +
  f(client_tier) * w2 +
  f(deadline_risk) * w3 +
  strategic_weight * w4 +
  lifecycle_weight * w5


Make the weights configurable per agency.

Non-revenue work

Don‚Äôt forget:

internal initiatives

technical debt

relationship / retention work

These need a ‚Äústrategic value‚Äù dimension so they don‚Äôt get starved.

Feedback from outcomes

After completion, compare:

predicted impact vs actual impact

Use that to:

bias future scores

update ‚Äústrategic weight‚Äù of similar task types.

1.4 Integration Points (Really Strong)

You wrote:

Predictions ‚Üí intelligence_signals

Priority Engine uses impact scoring

SLA Engine uses predictions for proactive breach alerts

Task creation triggers async prediction refresh

Workflow engine injects predictions when scheduling

From an architecture viewpoint, this is üëå:

Prediction as signal
Keeps your core engine clean: predictions just become one more signal type that workflows listen to.

SLA risk alerts
Beautiful: SLA engine uses predicted_duration + current_queue to forecast breaches.

Async refresh
Task creation / update triggers re-evaluation. Good for scalability and user experience.

Workflow integration
Scheduling workflows read from:

predictions

capacity profiles

commercial priority
‚Ä¶and produce assignment decisions.

The main ask now is: make Duration Intelligence a first-class domain in your docs.