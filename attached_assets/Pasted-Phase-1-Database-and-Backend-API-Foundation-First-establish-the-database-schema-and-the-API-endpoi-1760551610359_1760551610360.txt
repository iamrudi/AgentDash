Phase 1: Database and Backend API Foundation
First, establish the database schema and the API endpoints required to manage forms and handle public submissions.

1.1. Update the Database Schema

Modify shared/schema.ts to include three new tables: forms, formFields, and formSubmissions. Add this after the existing CRM tables.

File: shared/schema.ts

TypeScript

// ... (after the 'deals' table)

export const forms = pgTable('forms', {
  id: uuid('id').defaultRandom().primaryKey(),
  publicId: uuid('public_id').defaultRandom().notNull().unique(), // For public access
  name: text('name').notNull(),
  agencyId: uuid('agency_id')
    .notNull()
    .references(() => agencies.id, { onDelete: 'cascade' }),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
});

export const formFields = pgTable('form_fields', {
  id: uuid('id').defaultRandom().primaryKey(),
  formId: uuid('form_id')
    .notNull()
    .references(() => forms.id, { onDelete: 'cascade' }),
  label: text('label').notNull(),
  fieldType: text('field_type').notNull(), // e.g., 'text', 'email', 'textarea'
  placeholder: text('placeholder'),
  required: boolean('required').default(false).notNull(),
  order: integer('order').notNull(),
});

export const formSubmissions = pgTable('form_submissions', {
  id: uuid('id').defaultRandom().primaryKey(),
  formId: uuid('form_id')
    .notNull()
    .references(() => forms.id, { onDelete: 'cascade' }),
  agencyId: uuid('agency_id')
    .notNull()
    .references(() => agencies.id, { onDelete: 'cascade' }),
  data: jsonb('data').notNull(), // Store submitted form data as JSON
  createdAt: timestamp('created_at').defaultNow().notNull(),
});
1.2. Create the Form Management API

In server/routes/crm.ts, add the authenticated CRUD endpoints for managing forms and their fields.

File: server/routes/crm.ts

TypeScript

// ... (add to existing crmRouter file)

import { and } from 'drizzle-orm';

// ...

/**
 * @route POST /api/crm/forms
 * @description Create a new form
 * @access Private
 */
crmRouter.post('/forms', requireAuth, async (req, res, next) => {
  // ... Logic to create a new form and its fields for the agency ...
  // Ensure you insert with req.user.agencyId
});

/**
 * @route GET /api/crm/forms
 * @description Get all forms for the agency
 * @access Private
 */
crmRouter.get('/forms', requireAuth, async (req, res, next) => {
  // ... Logic to fetch all forms where agencyId = req.user.agencyId ...
});

// ... (Implement GET by ID, PUT, and DELETE endpoints for /api/crm/forms/:id)
1.3. Create the Public Submission Endpoint (High Security Concern)

Create a new file for public, unauthenticated routes. This endpoint will use the form's publicId to identify the correct agency, create a Contact and Deal, and log the submission. It MUST have its own strict rate limiter and a honeypot field for spam prevention.

New File: server/routes/public.ts

TypeScript

// server/routes/public.ts

import { Router } from 'express';
import rateLimit from 'express-rate-limit';
import { db } from '../db';
import * as schema from '../../shared/schema';
import { eq } from 'drizzle-orm';

const publicRouter = Router();

// Stricter rate limit for the public submission endpoint
const formSubmissionLimiter = rateLimit({
  windowMs: 5 * 60 * 1000, // 5 minutes
  limit: 10, // Max 10 submissions per IP every 5 minutes
  message: 'Too many submissions, please try again later.',
});

publicRouter.post(
  '/forms/:publicId/submit',
  formSubmissionLimiter,
  async (req, res) => {
    try {
      // 1. Honeypot spam check: if this field is filled out, it's a bot.
      if (req.body.honeypot_field) {
        return res.status(200).json({ message: 'Submission successful.' }); // Pretend it worked
      }
      
      const { publicId } = req.params;
      const submissionData = req.body;

      // 2. Find the form and its agency
      const form = await db.query.forms.findFirst({
        where: eq(schema.forms.publicId, publicId),
      });

      if (!form) {
        return res.status(404).send('Form not found.');
      }

      // 3. Create a new Contact
      const [newContact] = await db.insert(schema.contacts).values({
        email: submissionData.email, // Assuming 'email' is a standard field
        firstName: submissionData.firstName,
        lastName: submissionData.lastName,
        agencyId: form.agencyId,
      }).returning();
      
      // 4. Create a new Deal (Lead)
      await db.insert(schema.deals).values({
        name: `New lead from ${form.name}`,
        stage: 'lead',
        contactId: newContact.id,
        agencyId: form.agencyId,
      });

      // 5. Log the full submission
      await db.insert(schema.formSubmissions).values({
        formId: form.id,
        agencyId: form.agencyId,
        data: submissionData,
      });

      res.status(200).json({ message: 'Submission successful.' });
    } catch (error) {
      // Generic error to avoid leaking info
      res.status(500).send('An error occurred.');
    }
  },
);

export default publicRouter;
Now, register this new public router in server/index.ts before your authenticated routes.

File: server/index.ts

TypeScript

// ... (imports)
import publicRouter from './routes/public';
import apiRouter from './routes';

// ... (app setup)

// Public routes (no auth middleware)
app.use('/api/public', publicRouter);

// Authenticated API routes
app.use(apiRouter);

// ...
Phase 2: Frontend Form Builder and Embed Code
Build the user interface for creating and managing forms.

2.1. Create the Form Builder Page

Create a new page at client/src/pages/agency/crm/forms.tsx. This page will list existing forms and link to a builder page (/agency/crm/forms/new).

The builder interface should allow:

Setting a form name.

Adding/removing/reordering a list of fields. For this first version, support simple field types: text, email, textarea.

For each field, the user can set a label, placeholder, and toggle if it's required.

Use react-hook-form to manage the builder's state.

2.2. Create the Embed Code Component

On the form builder page, include a component that generates and displays the embed code. Start with an <iframe> for simplicity and security.

Example Component Logic:

TypeScript

function EmbedCodeDisplay({ formPublicId }: { formPublicId: string }) {
  const embedUrl = `${window.location.origin}/forms/embed/${formPublicId}`;
  const iframeCode = `<iframe src="${embedUrl}" width="100%" height="500px" frameborder="0"></iframe>`;

  // ... UI with a <pre> tag and a "Copy Code" button ...
}
Phase 3: The Embeddable Form Page
Create the public-facing page that will be loaded inside the <iframe>. This page will dynamically render a form and post to our public API.

3.1. Create the Embed Server Route

Create a new server route to render the form's HTML.

New File: server/routes/embed.ts

TypeScript

// server/routes/embed.ts
import { Router } from 'express';
// ... logic to fetch form and its fields by publicId ...

const embedRouter = Router();

embedRouter.get('/forms/embed/:publicId', async (req, res) => {
  const { publicId } = req.params;
  const form = // ... fetch form details from DB ...
  const fields = // ... fetch form fields from DB ...

  if (!form) return res.status(404).send('Not Found');
  
  // Render an HTML page with the form, including the honeypot field
  const formHtml = `
    <html>
      <head>...</head>
      <body>
        <form action="/api/public/forms/${publicId}/submit" method="POST">
          <input type="text" name="honeypot_field" style="display:none;">

          ${fields.map(field => `
            <div>
              <label>${field.label}</label>
              <input type="${field.fieldType}" name="${field.label.toLowerCase()}" ${field.required ? 'required' : ''}>
            </div>
          `).join('')}
          <button type="submit">Submit</button>
        </form>
      </body>
    </html>
  `;
  res.send(formHtml);
});

export default embedRouter;
Register this router in server/index.ts at the top level, as it serves HTML pages, not API responses.

Future Integrations
This foundational implementation creates a powerful, self-contained form system. Once complete, it can be extended:

WordPress Integration: Develop a dedicated WordPress plugin that uses an API key to fetch an agency's forms and renders them natively, rather than in an <iframe>.

LinkedIn Lead Gen Forms: Build a service that uses the LinkedIn API and webhooks. When a lead is captured on LinkedIn, the webhook would forward the data to a new, secure endpoint in our backend, which would then create the Contact and Deal.

These advanced integrations should be treated as separate, subsequent projects.